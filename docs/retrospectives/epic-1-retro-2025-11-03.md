# Epic 1 Retrospective - Split Index Architecture

**Date:** 2025-11-03
**Facilitator:** Bob (Scrum Master)
**Attendees:** Ryan (Product Owner/Developer)

---

## Epic 1 Summary

**Goal:** Enable claude-code-project-index to scale to large codebases (10,000+ files) by implementing a split architecture that separates lightweight core metadata from detailed module information.

**Delivery Metrics:**
- **Completed:** 8/8 stories (100%)
- **Stories:** 1.1 through 1.8 all marked done
- **Quality:** Tested on large project with success
- **Documentation:** README updated, migration guide added

**Business Outcomes:**
- âœ… Universal scalability achieved
- âœ… Core index remains under 100KB for large codebases
- âœ… Backward compatibility maintained - zero breaking changes
- âœ… Migration utility functional

---

## What Went Well

### Execution
- All 8 stories completed successfully
- Clean, production-ready implementation
- Strong testing validation on real large project

### Technical Decisions
- Split architecture design proved sound
- Backward compatibility strategy worked perfectly
- Configuration system (single/split/auto modes) flexible and robust

### Documentation
- README comprehensively updated
- Migration guide provides clear path for existing users
- Troubleshooting documentation added

---

## Key Learnings

### Architectural Insight: MCP Server Opportunity

During Epic 2 planning retrospective, identified that Epic 2's features (Stories 2.5-2.9) would benefit significantly from MCP server architecture:

**Benefits Discovered:**
- 10-50x performance improvement (10ms vs 300ms queries)
- True hybrid intelligence (index structure + MCP live content)
- Auto-update capability (Story 2.11)
- Reusability across tools (VSCode, CI/CD)

**Decision:** Add Stories 2.10-2.11 to Epic 2 for MCP server implementation

**Key Learning:** Deep knowledge gap assessment during retrospectives can uncover architectural opportunities that improve the next epic significantly.

---

## Epic 2 Preparation - Knowledge Gap Assessment

Conducted comprehensive assessment across 6 technical domains:

### Domain 1: Tiered Documentation System
**Gap Level:** ðŸŸ¢ Low

**Decisions:**
- Hybrid classification (filename patterns + content analysis)
- Weighted keyword matching (path:3x, function:2x, class:2x, import:1x)
- Config overrides for project-specific patterns

**Preparation Needed:**
- Design classification rules (header patterns, keywords)
- Set up doc-heavy test project

---

### Domain 2: Git Metadata & Temporal Awareness
**Gap Level:** ðŸŸ¢ Low

**Decisions:**
- Enhanced dual-pass approach (merge commits for PRs, work commits for timing/context)
- GitHub + Bitbucket PR extraction: `(pull request #NNN)` and `#NNN` patterns
- Step function temporal weighting (7d:5x, 30d:2x, 90d:1x, >90d:0.5x)
- Apply temporal weighting to filesystem mtime fallback
- Adjusted performance target: <30s for 10K files (realistic)

**Validation:**
- Tested against real Bitbucket repo: `/Users/rchoi/Developer/asure/asure.ptm.portal.web.ui.new`
- Confirmed merge commits have shallow context, work commits have rich messages
- Validated PR extraction pattern: `Merged in AS-2192 (pull request #409)`

**Key Insight:** Merge commit dates can mislead temporal scoring. Work commits provide accurate timing and better context.

---

### Domain 3: MCP Tool Integration
**Gap Level:** ðŸŸ¢ Low

**Decisions:**
- Probing detection with caching (auto-detect MCP tools)
- Always hybrid strategy (index for structure, MCP for freshness on top N)
- Always pre-filter with index before MCP Grep (ensures bounded performance)
- Transparent fallback (log warnings, continue workflow)
- Verbose logging: startup banner + per-query details

**Architecture:**
```
Index (structure/scoring) â†’ Top 5 candidates â†’ MCP Read (fresh content)
     10ms                        instant              50ms each
```

---

### Domain 4: Relevance Scoring Engine
**Gap Level:** ðŸŸ¢ Low

**Decisions:**
- Exact match explicit references (sufficient, no fuzzy matching needed)
- Weighted keyword matching (path:3x, function:2x, class:2x, import:1x)
- Unidirectional import relationships (if query mentions A, boost B that imports A)
- Simple configuration (can enhance later)
- Secondary sort by temporal for tie-breaking
- Minimum score threshold (0.5) to prevent loading irrelevant modules
- Load all available + warn if fewer than requested top-N
- Always use MCP Read for top files (when available)
- Verbose flag for scoring breakdown transparency

---

### Domain 5: Call Graph & Impact Analysis
**Gap Level:** ðŸŸ¢ Low

**Decisions:**
- Store lightweight call graph in core index (fast MCP server queries)
- Configurable traversal depth (default: 5 levels, None for unlimited)
- Report detected cycles (critical for refactoring insights)
- Output both flat and tree formats (flat for display, tree for programmatic)

**MCP Server Integration:**
```python
@mcp_tool
def index_impact_analysis(function_name: str, max_depth: int = 5) -> Dict:
    # Instant queries - graph already in memory
```

---

### Domain 6: Incremental Updates
**Gap Level:** ðŸŸ¢ Low

**Decisions:**
- Hybrid change detection (Git commit hash + file hash fallback)
- **Lazy invalidation** (mark modules stale on change, regenerate on-demand when queried)
- Auto-update: OFF by default (opt-in via config)
- Manual refresh endpoint always available
- Hash-based validation after updates
- Full regen triggers:
  1. Too many changes (>20% of files)
  2. Schema version mismatch
  3. Validation failure
  4. .gitignore changed
  5. User flag `--full`

**Key Innovation:** Lazy invalidation approach perfect for MCP server with file watching:
- Low cost on file change (just mark stale)
- Regenerate only queried modules
- Background cleanup during idle time (optional)

---

## Epic 2 Scope Update

**Original:** 9 stories (2.1-2.9)
**Updated:** 11 stories (2.1-2.11)

**New Stories:**

### Story 2.10: MCP Server Implementation

As a developer,
I want the index available as an MCP server,
So that agents can query it efficiently without parsing JSON.

**Acceptance Criteria:**
1. MCP server exposes tools: `index_search`, `index_get_module`, `index_score_relevance`, `index_impact_analysis`
2. Server loads index into memory on startup
3. Server supports all query patterns from Stories 2.1-2.9
4. Agent auto-detects MCP server and uses it if available
5. File-based fallback works when server unavailable
6. Performance: <10ms for search queries (vs ~300ms file-based)

---

### Story 2.11: MCP Server Auto-Update

As a developer,
I want the MCP server to watch for file changes,
So that my index stays fresh without manual regeneration.

**Acceptance Criteria:**
1. Server watches project directory for file changes (configurable patterns)
2. Lazy invalidation: marks modules stale on change
3. Regenerates stale modules on-demand when queried
4. Configuration for watch patterns (include/exclude paths)
5. Manual refresh endpoint available
6. Optional background cleanup (regenerate during idle)
7. Auto-update OFF by default (opt-in via config)

---

## Action Items

### Process Improvements
1. âœ… **Document architectural decisions in retrospectives** (Owner: SM, Timeline: Ongoing)
   - Successfully captured MCP server decision during Epic 2 planning
   - Continue this practice for future epics

### Epic 2 Preparation Sprint

**Technical Setup:**
- [ ] Install mcp-builder skill from https://github.com/anthropics/skills/tree/main/mcp-builder (Owner: Ryan, Est: 1 hour)
- [ ] Review MCP server patterns and tool registration (Owner: Ryan, Est: 2 hours)
- [ ] Set up doc-heavy test project for tiered documentation validation (Owner: Ryan, Est: 1 hour)

**Knowledge Development:**
- [x] Review Bitbucket repo git patterns (Owner: Ryan, **COMPLETE** during retro)
- [ ] Design tiered documentation classification rules (Owner: Ryan, Est: 2 hours)
  - Finalize header patterns for critical/standard/archive
  - Define edge case handling (docs/api/README.md)
- [ ] Design relevance scoring formula details (Owner: Ryan, Est: 1 hour)
  - Lock in exact weights for each signal
  - Define keyword extraction logic

**Architecture Documentation:**
- [ ] Document MCP server architecture decision (Owner: Ryan, Est: 1 hour)
  - Why MCP server in Epic 2 vs Epic 3
  - Benefits: 10-50x performance, auto-update, reusability
- [ ] Update Epic 2 scope in epics.md: Add Stories 2.10-2.11 (Owner: Ryan, Est: 30 minutes)

**Total Estimated Effort:** 8.5 hours (1-2 days)

---

## Critical Path

**Prerequisites Before Epic 2:**
1. âš ï¸ **mcp-builder skill installed and tested** (Must complete by: Before Story 2.10)
2. âš ï¸ **Doc-heavy test project identified** (Must complete by: Before Story 2.1)

**Dependencies Timeline:**
- Stories 2.1-2.9: Can start immediately (no blockers)
- Story 2.10: Requires mcp-builder skill setup
- Story 2.11: Requires Story 2.10 complete

**Risk Mitigation:**
- MCP server new territory: Start with mcp-builder skill to scaffold correctly
- Lazy invalidation complexity: Prototype stale marking logic in Story 2.9 before 2.11
- Auto-update performance: Make it opt-in (default OFF) to avoid thrashing

---

## Epic 1 Readiness Assessment

**Testing and Quality:** âœ… Complete
- All stories tested
- Validated on large project
- Production-ready

**Deployment Status:** âœ… Ready
- Split architecture live and usable
- Documented for adoption
- Migration utility functional

**Stakeholder Acceptance:** âœ… Met
- Core index < 100KB for large projects âœ…
- Backward compatibility maintained âœ…
- Migration utility works âœ…

**Technical Health:** âœ… Stable
- Clean implementation
- No technical debt identified
- Maintainable codebase

**Unresolved Blockers:** None

---

## Next Steps

1. **Execute Preparation Sprint** (Est: 1-2 days)
   - Install mcp-builder skill
   - Design classification rules
   - Set up test project

2. **Update Epic Documentation**
   - Add Stories 2.10-2.11 to epics.md
   - Document MCP server architectural decision

3. **Begin Epic 2 Implementation**
   - Start with Stories 2.1-2.2 (Tiered Documentation)
   - Progress through Stories 2.3-2.9
   - Build MCP server (Stories 2.10-2.11)

---

## Facilitator Notes

**Retrospective Quality:** Excellent

- Deep knowledge gap assessment across all 6 Epic 2 domains
- Identified MCP server opportunity early (preventing rework)
- Validated technical approaches against real Bitbucket repo
- All domains assessed as ðŸŸ¢ Low gap (ready to implement)
- Preparation sprint is focused and achievable (1-2 days)

**Key Success Factor:** The comprehensive domain-by-domain exploration uncovered that MCP server architecture actually *simplifies* Epic 2 implementation rather than complicating it. This is the value of thorough retrospective planning.

**Epic 2 Readiness:** ðŸŸ¢ **Ready to Start**

No major unknowns, clear implementation path, manageable preparation sprint.

---

**Scrum Master:** "Excellent work, Ryan! Epic 1 was rock solid, and Epic 2 has crystal-clear direction. The MCP server addition is exactly the right architectural move. Let's knock out that 1-2 day prep sprint and get started!"
